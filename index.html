<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title> 1.0.5.23</title>
<style>
  :root{
    --bg1:#0b1d16; /* deep forest */
    --bg2:#123726; /* mid */
    --bg3:#1d4d35; /* light canopy */
    --panel:#14241d;
    --panel-2:#1e2f27;
    --accent:#8fd3a8;   /* soft moss */
    --accent-2:#cbeac6; /* highlight */
    --warn:#a73232;     /* red for captures/blocked */
    --selected:#6cd14e;     /* selection */
    --ink:#e9f5ee;      /* text */
    --muted:#a8c7b6;
  }

body {
  margin: 0;
  color: var(--ink);
  background:
    /* Mist layer for depth */
    linear-gradient(to bottom, rgba(255,255,255,0.05), rgba(255,255,255,0.02) 50%, transparent 80%),
    /* Foliage: soft, irregular treetop blobs */
    radial-gradient(ellipse 40% 20% at 20% 30%, rgba(29,77,53,0.3) 10%, transparent 40%),
    radial-gradient(ellipse 30% 15% at 60% 20%, rgba(29,77,53,0.25) 10%, transparent 40%),
    radial-gradient(ellipse 35% 18% at 80% 35%, rgba(29,77,53,0.2) 10%, transparent 40%),
    /* Tree trunks: varied thickness and spacing */
    repeating-linear-gradient(90deg,
      rgba(0,0,0,0.15) 0px, rgba(0,0,0,0.15) 3px,
      transparent 3px, transparent 25px),
    repeating-linear-gradient(90deg,
      rgba(0,0,0,0.1) 0px, rgba(0,0,0,0.1) 2px,
      transparent 2px, transparent 40px),
    /* Base canopy gradient */
    linear-gradient(180deg, var(--bg3) 0%, var(--bg2) 45%, var(--bg1) 100%);
  min-height: 100vh;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}

  .wrap{
    max-width: 980px;
    margin: 0 auto;
    padding: 16px;
    align-items: center;
  }

  h1{
    margin:0 0 6px 0;
    font-weight:700;
    letter-spacing:.5px;
  }
  .sub{ color:var(--muted); margin-bottom:16px; }

  .row{
    display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start;
  }

  .panel{
    background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
    border:1px solid rgba(255,255,255,0.06);
    border-radius:12px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
  }

  /* Player info */
  .players{
    display:flex; justify-content:center; gap: 12px; width:min(88vw, 520px); margin: 20px auto;
  }
  .player{
    flex:1; padding:12px; text-align:center;
  }
  .turn{ outline:2px solid var(--accent); }

  /* Board */
  .board-wrap{
    display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start;
  }
  .board{
    aspect-ratio:1/1;
    display:grid;
    grid-template-columns: repeat(4, 1fr);
    gap:6px;
    padding:6px;
    width: min(88vw, 520px);
    margin: 24px auto 0;
  }

  .card{
    position:relative;
    border-radius:10px;
    display:flex; flex-direction:column;
    overflow:hidden;
    transition: transform .15s ease, box-shadow .15s ease, filter .15s ease;
    cursor:pointer;
    user-select:none;
    border:1px solid rgba(255,255,255,0.06);
  }
  .card.face-up{
    background: linear-gradient(180deg, #4f8e39 0%, #1e3a2f 100%);
  }
  .card.face-down{
    background:
      linear-gradient(135deg, #2a3e34 0%, #1b3128 100%),
      repeating-linear-gradient(45deg,
        rgba(255,255,255,0.06) 0 6px,
        rgba(255,255,255,0.02) 6px 12px);
    filter:saturate(.9);
  }
  .card.impassable{
    transform: rotate(90deg);
    background: linear-gradient(180deg, #334a41 0%, #2a3e34 100%);
    filter: grayscale(.1) brightness(.95);
  }
  .name {
    font-size: .85rem;
    text-align: center;
    padding: 6px 4px 0 4px;
    color: var(--accent-2);
    height: 20%;          /* force consistent height */
    display: flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;  /* prevent wrapping */
    overflow: hidden;     /* clip long text */
    text-overflow: ellipsis;
    position: relative;
    z-index: 3;
  }
  .name.mushroom {
    font-size: 0.7rem;    /* smaller so "Mushroom Ring" fits */
    line-height: 1.1;     /* tighter spacing */
    white-space: normal;  /* allow wrapping */
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .token-area {
  flex: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 55px; /* matches token size */
}

/* Token container */
.token {
  width: 55px;
  height: 55px;
  font-size: 5.5rem;         /* Emoji size */
  line-height: 1;
  display: flex;             /* Center emoji */
  align-items: center;
  justify-content: center;
  position: relative;        /* For ::after pseudo-element */
  box-sizing: border-box;
  z-index: 2;
}

/* Bloodied state overlay */
.token.bloodied::after {
  content: "";
  position: absolute;
  width: 35%;                /* Circle slightly smaller than token */
  height: 35%;
  border-radius: 100%;
  border: 10px solid rgb(194, 56, 56);
  filter: blur(4px);
  top: 50%;
  left: 50%;
  transform: translate(-50%, -20%);
  box-shadow: 0 0 0px var(--warn), inset 0 0 0px var(--warn); /* Red glow for bloodied */
  border-color: var(--warn); /* Red border for bloodied */
  pointer-events: none;      /* Don’t block clicks */
  z-index: 1;
}

.token span {
  position: relative;
  z-index: 3; /* Higher than token container */
}

.white {
  background: #00000000; /* Dark background for white player */
  color: #FFF; /* Light font for white king emoji */
  /*border: 2px solid #f0f6f3; /* White border */
  /*box-shadow: 0 0 8px rgba(240,246,243,0.6), 0 4px 12px rgba(0,0,0,0.3); /* White glow + default shadow */
}
.black {
  background: #ffffff00; /* Light background for black player */
  color: #000; /* Dark font for black king emoji */
  /*border: 2px solid #22352c; /* Black border */
  /*box-shadow: 0 0 8px rgba(34,53,44,0.6), 0 4px 12px rgba(0,0,0,0.3); /* Black shadow + default shadow */
}

/* Animation for selected or bloodied tokens */
@keyframes pulse {
  0% { transform: scale(0.95); }
  50% { transform: scale(1.05); }
  100% { transform: scale(0.95); }
}

  .cube{
    width:50%; height:50%;
    background:#2e5a48; color:#e6fff2; border:2px solid #091a14;
    display:flex; align-items:center; justify-content:center;
    font-weight:800; letter-spacing:.5px;
    position:absolute; z-index:2;
    box-shadow: 0 4px 12px rgba(0,0,0,.35);
  }
  .blocked{ outline:3px solid var(--warn); outline-offset:-3px; }

  /* Highlights */
  .hl-move{ box-shadow: inset 0 0 0 4px rgba(143,211,168,.85); }
  .hl-cap{  box-shadow: inset 0 0 0 4px rgba(229,103,103,.95); }
  .hl-sel{  outline:3px solid var(--selected); outline-offset:-3px; z-index:3; }
  .hl-cube{ box-shadow: inset 0 0 0 4px rgb(161,199,101); } /* block cube highlight */
  /* Hover polish */
  .card:not(.impassable):hover{ transform: scale(1.03); }
  .card.impassable:hover{ transform: rotate(90deg) scale(1.0); cursor:not-allowed; }

  /* Controls & messages */
  .controls-panel {
    max-width: 520px;
    margin: 24px auto 0;
    padding: 10px;
    flex-direction: column;
    gap: 10px;
  }
  .controls{
    display:flex; flex-wrap:wrap; align-items:center; margin-top: auto; justify-content: center; gap:8px;
  }
  .btn{
    background:#244d3b; border:1px solid rgba(255,255,255,0.08);
    color:var(--ink);
    padding:8px 12px; border-radius:10px; cursor:pointer;
    transition: transform .1s ease, filter .1s ease, background .2s;
  }
  .btn:hover{ filter:brightness(1.1); transform:translateY(-1px); }
  .btn:disabled{ opacity:.5; cursor:not-allowed; }
  .choice{ display:none; gap:8px; }
  .choice.show{ display:flex; }

  .message{
    padding:10px 12px; min-height:24px; color:var(--accent-2);
  }

  .btn.disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* Modal */
  .backdrop{
    position:fixed; inset:0; background: rgba(0,0,0,.6);
    display:flex; align-items:center; justify-content:center;
    z-index: 9999;
  }
  .modal{
    background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
    border:1px solid rgba(255,255,255,0.08);
    color:var(--ink);
    padding:20px; border-radius:14px; width:min(92vw, 420px);
    text-align:center;
    box-shadow: 0 16px 40px rgba(0,0,0,.45);
  }
  
  /* rules-section */
 .rules-section {
  background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 12px;
  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
  color: var(--ink);
  font-size: 0.9rem;
  box-sizing: border-box;
  width: min(88vw, 520px);
  margin: 24px auto 0;
}
.rules-section h2 {
  font-weight:700;
  letter-spacing:.5px;
}
.rules-section ul li {
  margin-bottom:4px;
}
.rules-section ul li ul li {
  margin-bottom:2px;
}
</style>
</head>
<body>
  <div class="wrap">
    <h1>We Are Kings | 1.0.5.23</h1>
    <div class="sub">Best of three matches wins the game | To win match: Capture opponent twice • Reveal the last facedown card • Opponent has no valid moves • </div>

    <div class="players row">
      <div id="player-white-info" class="panel player">
        <div style="font-weight:700">Player White</div>
        <div>Captures: <span id="white-captures">0</span>/2</div>
        <div>Matches Won: <span id="white-matches">0</span></div>
      </div>
      <div id="player-black-info" class="panel player">
        <div style="font-weight:700">Player Black</div>
        <div>Captures: <span id="black-captures">0</span>/2</div>
        <div>Matches Won: <span id="black-matches">0</span></div>
      </div>
    </div>

    <div class="board-wrap row" style="margin-top:12px;">
      <div class="panel board" id="game-board"></div>
    </div>

    <div class="panel controls-panel">
      <div class="message" id="message-board"></div>
      <div class="controls">
        <div id="move-choice" class="choice">
            <button id="king-move-btn" class="btn" aria-label="Perform King Action">King Action</button>
            <button id="card-move-btn" class="btn" aria-label="Perform Card Action">Card Action</button>
            <button id="mushroom-move-btn" class="btn" aria-label="Perform Mushroom Teleport">Mushroom Teleport</button>
        </div>
        <button id="undo-btn" class="btn" aria-label="Undo Last Move">Undo</button>
        <button id="ai-toggle-btn" class="btn" aria-label="Toggle AI Opponent">Play vs AI: Off</button>
      </div>
      <select id="ai-difficulty" class="btn" style="display:none;" aria-label="Select AI Difficulty">
          <option value="easy">Easy</option>
          <option value="medium" selected>Medium</option>
          <option value="hard">Hard</option>
      </select>
    </div>
  </div>

  <div class="rules-section panel" style="margin-top:24px; padding:12px;">
    <h2 style="margin-top:0; margin-bottom:8px;">Rules Reference</h2>
    <ul style="padding-left:20px; margin:0; line-height:1.5;">
      <li>Each player starts on a <strong>King Start</strong> card.</li>
      <li>On your turn, select your token and choose an action:
        <ul>
          <li><strong>King Action</strong>: Move 1 space in any direction, then place a block cube.</li>
          <li><strong>Card Action</strong>: Move according to your card’s movement pattern; captures allowed. (Origin becomes impassable)</li>
          <li><strong>Mushroom Teleport</strong>: Jump to any face-up Mushroom Ring.</li>
        </ul>
      </li>
      <br>
      <li><strong>Captures</strong>: Wound the opponent and place them on an adjacent highlighted space. Immediate recaptures from last capture origin are prohibited. If there are no valid placements after capture; you win!</li>
      <li>Sliding pieces (Rook, Bishop, Queen) cannot pass through impassable spaces but Knights can jump over impassable spaces.</li>
      <li>Start cards become Mushroom Rings after moving.</li>
      <li>The first player to capture twice or flip the last facedown card wins the match.</li>
      <li>If a player has no valid moves on their turn, they lose.</li>
      <br>
      <li><strong>Impassable</strong>: When a card is used in a <strong>Card Action</strong> it becomes impassable. It is turned 90 degrees, and cannot be moved through or landed on; with the exception of the Knight who can jump over them but not land on them</li>
    </ul>
  </div>

  <div id="modal" class="backdrop" style="display:none;">
    <div class="modal">
      <h2 id="modal-title" style="margin:0 0 8px 0;">Begin Match</h2>
      <p id="modal-text" style="margin:0 0 14px 0;">White goes first.</p>
      <button id="modal-button" class="btn" aria-label="Start Game">Start</button>
    </div>
  </div>

<script>

function showAlert(message) {
    //alert(message);
    modal.style.display = 'flex';
    modalTitle.textContent = 'Game Update';
    modalText.textContent = message;
    modalButton.textContent = 'OK';
    modalButton.onclick = () => {
        modal.style.display = 'none';
    };
}

/* ===== Rows & Cols ===== */
const ROWS = 4;
const COLS = 4;
/* ===== Card Types ===== */
const CARD_TYPES = {
  KING:       { name: 'King',          move: 'king' },
  ROOK:       { name: 'Rook',          move: 'rook' },
  BISHOP:     { name: 'Bishop',        move: 'bishop' },
  KNIGHT:     { name: 'Knight',        move: 'knight' },
  QUEEN:      { name: 'Queen',         move: 'queen' },
  MUSHROOM:   { name: 'Mushroom Ring', move: 'mushroom' },
  START_KING: { name: 'King Start',    move: 'king_start', impassableName: 'Mushroom Ring' },
};

/* ===== DOM ===== */
const gameBoard    = document.getElementById('game-board');
const messageBoard = document.getElementById('message-board');
const undoBtn      = document.getElementById('undo-btn');
const choiceBar    = document.getElementById('move-choice');
const kingBtn      = document.getElementById('king-move-btn');
const cardBtn      = document.getElementById('card-move-btn');
const mushBtn      = document.getElementById('mushroom-move-btn');
const aiToggleBtn  = document.getElementById('ai-toggle-btn');
const aiDifficulty = document.getElementById('ai-difficulty');

const modal        = document.getElementById('modal');
const modalTitle   = document.getElementById('modal-title');
const modalText    = document.getElementById('modal-text');
const modalButton  = document.getElementById('modal-button');

/* ===== Game State ===== */
let gameState = {}; // Will be initialized in startNewGame

/* ===== Token select ===== */
function makeToken(color) {
  const d = document.createElement('div');
  d.className = `token ${color}`;
  d.setAttribute('aria-label', `${cap(color)} King`);

  // King inside a span (prevents layout shift when adding badge)
  const king = document.createElement('span');
  king.textContent = color === 'white' ? '♔' : '♔';
  d.appendChild(king);

  // Always check the current bloodied state
  if (gameState.players[color].isBloodied) {

    d.classList.add('bloodied');
    d.setAttribute('aria-label', `${cap(color)} King (Wounded)`);
  } else {
    d.classList.remove('bloodied');
  }

  // Highlight if selected
  const sel = gameState.selectedTokenPos;
  if (sel && sel.r === gameState.players[color].pos.r && sel.c === gameState.players[color].pos.c) {
    d.style.transform = "scale(1.05)";
    d.style.boxShadow = "0 0 12px var(--gold), 0 6px 16px rgba(0,0,0,0.35)";
    d.style.animation = "pulse 1s ease-in-out infinite";
    d.style.zIndex = 5;
  } else {
    d.style.transform = "scale(1.0)";
    d.style.animation = "";
  }
  return d;
}

/* ===== History (Undo) ===== */
let history = [];
function saveState() {
  const copy = JSON.parse(JSON.stringify(gameState));
  history.push(copy);
  undoBtn.disabled = false;
}
function undoMove() {
  if (history.length <= 1) return; // Can't undo past the start of the turn
  history.pop(); // Remove current state
  gameState = JSON.parse(JSON.stringify(history[history.length - 1])); // Load previous
  renderBoard();
  setMessage("Undone. Your turn.");
  autoSelectToken();
}

/* ===== Helpers ===== */
const keyRC = (r, c) => `${r},${c}`;
const cap = s => s.charAt(0).toUpperCase() + s.slice(1);
const setMessage = txt => messageBoard.textContent = txt;

function isValidPosition(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }
function isOccupiedByPlayer(r, c, color) {
  const p = gameState.players[color].pos;
  return p && p.r === r && p.c === c;
}
function isOccupied(r, c) { return isOccupiedByPlayer(r, c, 'white') || isOccupiedByPlayer(r, c, 'black'); }
function isImpassable(r, c) {
  const card = gameState.board[r][c];
  if (card.isImpassable) return true;
  if (gameState.blockCubePos && gameState.blockCubePos.r === r && gameState.blockCubePos.c === c) return true;
  return false;
}
function isValidMove(r, c) { return isValidPosition(r, c) && !isImpassable(r, c); }

function countFaceDown() {
  return gameState.board.flat().filter(c => !c.isFaceUp).length;
}
function clearHighlights() {
  gameState.highlights.map = {};
  gameState.highlights.capSpots = [];
  gameState.highlights.selection = null;
}
function updatePlayerInfo() {
  document.getElementById('white-captures').textContent = gameState.players.white.captures;
  document.getElementById('black-captures').textContent = gameState.players.black.captures;
  document.getElementById('white-matches').textContent = gameState.players.white.matches;
  document.getElementById('black-matches').textContent = gameState.players.black.matches;
}
function updateTurnIndicator() {
  const wi = document.getElementById('player-white-info');
  const bi = document.getElementById('player-black-info');
  wi.classList.remove('turn'); bi.classList.remove('turn');
  if (!gameState.isGameOver) {
    (gameState.currentPlayer === 'white' ? wi : bi).classList.add('turn');
  }
}
function autoSelectToken() {
  const me = gameState.players[gameState.currentPlayer];
  if (!me.pos) return;
  onCellClick(me.pos.r, me.pos.c);
}

/* ===== Setup & Match Flow ===== */
function init() {
  undoBtn.onclick = undoMove;
  aiToggleBtn.onclick = toggleAI;
  aiDifficulty.onchange = (e) => gameState.aiDifficulty = e.target.value;

  // Add keyboard support for accessibility
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && gameState.selectedTokenPos) {
      showChoices(gameState.selectedTokenPos.r, gameState.selectedTokenPos.c);
    }
  });

  startNewGame();
}

function startNewGame() {
  gameState = {
    board: [],
    players: {
      white: { captures: 0, matches: 0, isBloodied: false, pos: null },
      black: { captures: 0, matches: 0, isBloodied: false, pos: null },
    },
    currentPlayer: 'white',
    turnCount: 0,
    selectedTokenPos: null,
    turnAction: null,
    capturePlacementData: null,
    blockCubePos: null,
    lastCaptureOrigin: null,
    justCaptured: null,
    isGameOver: true,
    aiEnabled: false,
    aiDifficulty: 'medium',
    aiThinking: false,
    highlights: { map: {}, capSpots: [], selection: null },
    debug: false
  };
  history = [];
  showModal("Begin Game", "White goes first. Best of three matches wins the game.", "Start", startNewMatch);
}

function startNewMatch() {
  // Reset match-specific state
  gameState.isGameOver = false;
  gameState.board = [];
  for (const side of ['white', 'black']) {
    const p = gameState.players[side];
    p.captures = 0; p.isBloodied = false; p.pos = null;
  }
  gameState.blockCubePos = null;
  gameState.selectedTokenPos = null;
  gameState.turnAction = null;
  gameState.capturePlacementData = null;
  clearHighlights();
  setupBoard();
  
  gameState.currentPlayer = 'white';
  gameState.oppPlayer = 'black';
  gameState.turnCount = 0;
  
  setMessage(`${cap(gameState.currentPlayer)}, place your token on a 'King Start' card.`);
  history = [JSON.parse(JSON.stringify(gameState))];
  undoBtn.disabled = true;

  renderBoard();
}

function setupBoard() {
  const deck = [
    ...Array(4).fill(CARD_TYPES.KING),
    ...Array(4).fill(CARD_TYPES.ROOK),
    ...Array(2).fill(CARD_TYPES.BISHOP),
    ...Array(2).fill(CARD_TYPES.KNIGHT),
    ...Array(2).fill(CARD_TYPES.QUEEN),
  ];
  if (deck.length < ROWS * COLS - 2) {
    if (gameState.debug) console.error("Insufficient cards in deck!");
    return;
  }
  // Shuffle
  for (let i = deck.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }

  const grid = Array(ROWS * COLS).fill(null);
  grid[0] = CARD_TYPES.START_KING;
  grid[ROWS * COLS - 1] = CARD_TYPES.START_KING;

  let di = 0;
  for (let i = 0; i < 16; i++) if (!grid[i]) grid[i] = deck[di++];

  gameState.board = [];
  for (let r = 0; r < ROWS; r++) {
    gameState.board[r] = [];
    for (let c = 0; c < COLS; c++) {
      const card = grid[r * COLS + c];
      gameState.board[r][c] = {
        ...card,
        isFaceUp: card.name === CARD_TYPES.START_KING.name,
        isImpassable: false,
        row: r, col: c,
      };
    }
  }
  // Center 4 face-up
  gameState.board[1][1].isFaceUp = true;
  gameState.board[1][2].isFaceUp = true;
  gameState.board[2][1].isFaceUp = true;
  gameState.board[2][2].isFaceUp = true;
}

/* ===== Rendering ===== */
function renderBoard() {
  gameBoard.innerHTML = '';
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const card = gameState.board[r][c];
      const cell = document.createElement('div');
      cell.className = 'card';
      cell.dataset.row = r; cell.dataset.col = c;

      cell.classList.toggle('face-up', card.isFaceUp);
      cell.classList.toggle('face-down', !card.isFaceUp);
      cell.classList.toggle('impassable', card.isImpassable);

      const nameDiv = document.createElement('div');
      nameDiv.className = 'name';
      let displayName = card.isFaceUp ? card.name : '';
      if (card.isImpassable && card.impassableName) {
        displayName = card.impassableName;
        nameDiv.classList.add('mushroom');
      }
      nameDiv.textContent = displayName;
      cell.appendChild(nameDiv);

      const area = document.createElement('div');
      area.className = 'token-area';

      if (gameState.blockCubePos && gameState.blockCubePos.r === r && gameState.blockCubePos.c === c) {
        cell.classList.add('blocked');
        const cube = document.createElement('div');
        cube.className = 'cube';
        cube.textContent = 'B';
        area.appendChild(cube);
      }

      if (isOccupiedByPlayer(r, c, 'white')) area.appendChild(makeToken('white'));
      if (isOccupiedByPlayer(r, c, 'black')) area.appendChild(makeToken('black'));

      cell.appendChild(area);

      const key = keyRC(r, c);
      if (gameState.highlights.selection && gameState.highlights.selection.r === r && gameState.highlights.selection.c === c) {
        cell.classList.add('hl-sel');
      } else if (gameState.turnAction === 'capture_placement' && gameState.highlights.capSpots.includes(key)) {
        cell.classList.add('hl-move');
      } else if (gameState.turnAction === 'king_block') {
        if (!isOccupied(r, c) && !isImpassable(r, c)) cell.classList.add('hl-cube');
      } else if (gameState.highlights.map[key]) {
        const info = gameState.highlights.map[key];
        cell.classList.add(info.isCapture ? 'hl-cap' : 'hl-move');
      }

      cell.addEventListener('click', () => onCellClick(r, c));
      gameBoard.appendChild(cell);
    }
  }
  updatePlayerInfo();
  updateTurnIndicator();
}



/* ===== Click Flow ===== */
function onCellClick(r, c) {
  if (gameState.isGameOver || (gameState.aiEnabled && gameState.currentPlayer === 'black')) return;
  
  if (!gameState.players.white.pos || !gameState.players.black.pos) {
    handleInitialPlacement(r, c);
    return;
  }

  if (gameState.turnAction === 'capture_placement') {
    const key = keyRC(r, c);
    if (!gameState.highlights.capSpots.includes(key)) {
      setMessage("Choose a highlighted adjacent cell.");
      return;
    }
    const { opponentColor } = gameState.capturePlacementData;
    gameState.players[opponentColor].pos = { r, c };

    if (!gameState.board[r][c].isFaceUp) {
      gameState.board[r][c].isFaceUp = true;
      if (countFaceDown() === 0) {
        endGame(opponentColor, "flipped the last card on relocation!");
        return;
      }
    }
    
    gameState.capturePlacementData = null;
    gameState.turnAction = null;
    clearHighlights();
    endTurn();
    return;
  }

  if (gameState.turnAction === 'king_block') {
    if (!isOccupied(r, c) && !isImpassable(r, c)) {
      gameState.blockCubePos = { r, c };
      gameState.turnAction = null;
      endTurn();
    } else {
      setMessage("Invalid block placement.");
    }
    return;
  }

  const me = gameState.players[gameState.currentPlayer];
  if (me.pos && me.pos.r === r && me.pos.c === c) {
    if (gameState.selectedTokenPos && gameState.selectedTokenPos.r === r && gameState.selectedTokenPos.c === c) {
      gameState.selectedTokenPos = null;
      clearHighlights();
      choiceBar.classList.remove('show');
      renderBoard();
      return;
    }

    gameState.selectedTokenPos = { r, c };
    clearHighlights();
    gameState.highlights.selection = { r, c };
    showChoices(r, c);
    renderBoard();
    return;
  }

  const key = keyRC(r, c);
  if (gameState.highlights.map[key]) {
    handleMove(r, c, gameState.highlights.map[key]);
    return;
  }

  gameState.selectedTokenPos = null;
  clearHighlights();
  choiceBar.classList.remove('show');
  renderBoard();
}

function handleInitialPlacement(r, c) {
  const cell = gameState.board[r][c];
  if (cell.name !== CARD_TYPES.START_KING.name) {
    setMessage("Place on a 'King Start' card.");
    return;
  }
  const other = gameState.currentPlayer === 'white' ? 'black' : 'white';
  if (gameState.players[other].pos && gameState.players[other].pos.r === r && gameState.players[other].pos.c === c) {
    setMessage("That start card is occupied.");
    return;
  }
  gameState.players[gameState.currentPlayer].pos = { r, c };

  if (!gameState.players.black.pos) {
    gameState.currentPlayer = 'black';
    setMessage(`${cap(gameState.currentPlayer)}, place your token on a 'King Start' card.`);
    if (gameState.aiEnabled && gameState.currentPlayer === 'black') {
      setTimeout(makeAIMove, 500);
    }
  } else {
    gameState.currentPlayer = 'white';
    setMessage("White's turn. Select your token.");
    autoSelectToken();
  }
  saveState();
  renderBoard();
}

/* ===== Move Handling ===== */
function handleMove(r, c, info) {
  saveState();
  const me = gameState.players[gameState.currentPlayer];
  const fromR = me.pos.r, fromC = me.pos.c;
  const opponentColor = gameState.currentPlayer === 'white' ? 'black' : 'white';

  // Move player
  me.pos = { r, c };

  // Flip card if face down
  if (!gameState.board[r][c].isFaceUp) {
    gameState.board[r][c].isFaceUp = true;
  }

  // Handle Mushroom Teleport
  if (info.type === 'mushroom_move') {
    gameState.board[r][c].isImpassable = false; // Ensure not impassable if it was a mushroom ring
    showAlert(`${cap(gameState.currentPlayer)} teleports to a Mushroom Ring!`); //showalert
  }

  // Convert start card to mushroom ring
  const originCard = gameState.board[fromR][fromC];
  if (originCard.name === CARD_TYPES.START_KING.name) {
    originCard.name = CARD_TYPES.MUSHROOM.name;
    originCard.move = CARD_TYPES.MUSHROOM.move;
    originCard.isImpassable = false; //test
  } else if (info.type === 'action_move') {
    originCard.isImpassable = true; // Ensure not impassable if it was a mushroom ring
  }

  choiceBar.classList.remove('show');
  clearHighlights();

  // Handle capture
  if (info.isCapture) {
    me.captures++;
    me.isBloodied = false;
    gameState.players[opponentColor].isBloodied = true;
    gameState.lastCaptureOrigin = { r, c };
    gameState.justCaptured = opponentColor;
    gameState.turnAction = 'capture_placement';
    gameState.capturePlacementData = { opponentColor, fromR: r, fromC: c };
    gameState.highlights.capSpots = [];

    showAlert(`${cap(gameState.currentPlayer)} has captured ${cap(opponentColor)}!`); //showalert

    // Highlight adjacent spots for relocation
    for (let dr = -1; dr <= 1; dr++) {
      for (let dc = -1; dc <= 1; dc++) {
        if (dr === 0 && dc === 0) continue;
        const nr = r + dr, nc = c + dc;
        if (isValidMove(nr, nc) && !isOccupied(nr, nc)) {
          gameState.highlights.capSpots.push(keyRC(nr, nc));
        }
      }
    }

    // Check if there are no valid placement spots
    if (gameState.highlights.capSpots.length === 0) {
        endGame(gameState.currentPlayer, `${cap(opponentColor)} has no valid placement spots.`);
        return;
    }

    setMessage(`${cap(gameState.currentPlayer)}, place your opponent on an adjacent tile.`);
    renderBoard();

    // AI auto-placement
   if (gameState.aiEnabled && gameState.currentPlayer === 'black') {
      setTimeout(makeAIMove, 500);
    }
    return;
  } else if (info.type === 'king_move') {
    gameState.turnAction = 'king_block';
    setMessage(`${cap(gameState.currentPlayer)}, place a block cube.`);
    renderBoard();
    
    if (gameState.aiEnabled && gameState.currentPlayer === 'black') {
      setTimeout(() => {
        const possibleBlocks = [];
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (!isImpassable(r, c) && !isOccupied(r, c)) {
              possibleBlocks.push({ r, c });
            }
          }
        }
        if (possibleBlocks.length > 0) {
          const blockPos = possibleBlocks[Math.floor(Math.random() * possibleBlocks.length)];
          gameState.blockCubePos = { r: blockPos.r, c: blockPos.c };
          gameState.turnAction = null;
          renderBoard();
          endTurn();
        }
      }, 500);
    }
    return;
  }
  endTurn();
}

function endTurn() {
  // Check win conditions
  const me = gameState.players[gameState.currentPlayer];
  if (me.captures >= 2) {
    endGame(gameState.currentPlayer, "has captured their opponent twice!");
    return;
  }
  if (countFaceDown() === 0) {
    endGame(gameState.currentPlayer, "has revealed the last face-down card!");
    return;
  }

  // Switch player
  gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
  gameState.turnCount++;
  gameState.selectedTokenPos = null;
  if (gameState.justCaptured !== gameState.currentPlayer) {
    gameState.justCaptured = null;
    gameState.lastCaptureOrigin = null;
  }
  clearHighlights();
  
  renderBoard();

  // Check if new player has any moves
  const allMoves = generateAllMovesForPlayer(gameState.currentPlayer);
  if (allMoves.length === 0) {
    const winner = gameState.currentPlayer === 'white' ? 'black' : 'white';
    endGame(winner, `${cap(gameState.currentPlayer)} has no valid moves.`);
    return;
  }

  setMessage(`${cap(gameState.currentPlayer)}'s turn.`);
  autoSelectToken();
  saveState();

  // AI move if enabled
  if (gameState.aiEnabled && gameState.currentPlayer === 'black') {
    setTimeout(makeAIMove, 750);
  }
}

function endGame(winner, reason) {
  gameState.isGameOver = true;
  gameState.players[winner].matches++; // Increment match count
  renderBoard();

  if (gameState.players[winner].matches >= 2) {
    showModal(`${cap(winner)} Wins the Game!`, `${cap(winner)} has won ${gameState.players[winner].matches} matches.`, "New Game", startNewGame);
  } else {
    showModal(`${cap(winner)} Wins the Match!`, reason, "Next Match", startNewMatch);
  }
}

// ===== Logging =====
function logDataToSheet(winner, reason) {
  const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbzUGfDj_GCJkN9bj9mASdAQYjyg_deJDdRbginA60c-tmseMvt7TGrRe85KlICZT0n2/exec';

  const data = {
    winner: winner,
    reason: reason,
    whiteMatches: gameState.players.white.matches,
    blackMatches: gameState.players.black.matches
  };

  fetch(SCRIPT_URL, {
    method: 'POST',
    mode: 'no-cors', // Important for sending from a local file or different domain
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(data)
  })
  .then(response => console.log('Successfully logged game data.'))
  .catch(error => console.error('Error logging data:', error));
}
// ====================================================================

function showModal(title, text, buttonText, onClick) {
  modal.style.display = 'flex';
  modalTitle.textContent = title;
  modalText.textContent = text;
  modalButton.textContent = buttonText;
  modalButton.onclick = () => {
    modal.style.display = 'none';
    onClick();
  };
}

/* ===== Action Choice UI ===== */
function showChoices(r, c) {
  choiceBar.classList.add('show');
  
  function toggleButton(btn, hasMoves, onClick) {
    btn.disabled = !hasMoves;
    btn.classList.toggle('disabled', !hasMoves);
    btn.onclick = hasMoves ? onClick : null;
  }

  const kingMoves = getKingMoves(r, c);
  toggleButton(kingBtn, kingMoves.length > 0, () => highlightMoves(r, c, kingMoves, 'king_move'));

  const cardMoves = getPieceMoves(r, c, gameState.board[r][c].move, gameState.currentPlayer);
  toggleButton(cardBtn, cardMoves.length > 0, () => highlightMoves(r, c, cardMoves, 'action_move'));
  
  const mushroomMoves = getMushroomMoves(r, c);
  toggleButton(mushBtn, mushroomMoves.length > 0, () => highlightMoves(r, c, mushroomMoves, 'mushroom_move'));

  if (kingMoves.length === 0 && cardMoves.length === 0 && mushroomMoves.length === 0) {
    setMessage("No valid moves available.");
  } else {
    setMessage("Select a move type:");
  }
}

/* ===== Move Generation ===== */
function highlightMoves(r, c, moves, type) {
  clearHighlights();
  gameState.highlights.selection = { r, c };
  for (const m of moves) {
    gameState.highlights.map[keyRC(m.r, m.c)] = { ...m, type };
  }
  renderBoard();
}

function getKingMoves(r, c) {
  const moves = [];
  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      if (dr === 0 && dc === 0) continue;
      const nr = r + dr, nc = c + dc;
      if (isValidMove(nr, nc) && !isOccupied(nr, nc)) {
        moves.push({ r: nr, c: nc, isCapture: false });
      }
    }
  }
  return moves;
}

function getMushroomMoves(r, c) {
  const moves = [];
  for (let row = 0; row < 4; row++) {
    for (let col = 0; col < 4; col++) {
      const t = gameState.board[row][col];
      if (row === r && col === c) continue;
      if (t.move === 'mushroom' && t.isFaceUp && !isImpassable(row, col) && !isOccupied(row, col)) {
        moves.push({ r: row, c: col, isCapture: false });
      }
    }
  }
  return moves;
}

function getPieceMoves(r, c, piece, meColor) {
  const opp = meColor === 'white' ? 'black' : 'white';
  const moves = [];
  const dirs = {
    rook: [[-1, 0], [1, 0], [0, -1], [0, 1]],
    bishop: [[-1, -1], [-1, 1], [1, -1], [1, 1]],
    queen: [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]],
    king: [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]],
    knight: [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]],
  };
  const sliding = ['rook', 'bishop', 'queen'].includes(piece);
  const vecs = dirs[piece] || [];

  const isLastOrigin = gameState.lastCaptureOrigin && gameState.lastCaptureOrigin.r === r && gameState.lastCaptureOrigin.c === c;
  const wasJustCaptured = gameState.justCaptured === meColor;

  for (const [dr, dc] of vecs) {
    let nr = r + dr, nc = c + dc;
    if (sliding) {
      while (isValidPosition(nr, nc)) {
        if (isImpassable(nr, nc)) break;
        if (isOccupiedByPlayer(nr, nc, meColor)) break;
        const isCap = isOccupiedByPlayer(nr, nc, opp);
        if (!(isCap && wasJustCaptured)) {
          moves.push({ r: nr, c: nc, isCapture: isCap });
        }
        if (isCap) break;
        nr += dr; nc += dc;
      }
    } else {
      if (isValidMove(nr, nc) && !isOccupiedByPlayer(nr, nc, meColor)) {
        const isCap = isOccupiedByPlayer(nr, nc, opp);
        if (!(isCap && wasJustCaptured)) {
          moves.push({ r: nr, c: nc, isCapture: isCap });
        }
      }
    }
  }
  return moves;
}

function generateAllMovesForPlayer(color) {
  const player = gameState.players[color];
  if (!player.pos) return [];
  const { r, c } = player.pos;
  const card = gameState.board[r][c];

  const allMoves = [
    ...getKingMoves(r, c).map(m => ({ ...m, type: 'king_move' })),
    ...getPieceMoves(r, c, card.move, color).map(m => ({ ...m, type: 'action_move' })),
    ...getMushroomMoves(r, c).map(m => ({ ...m, type: 'mushroom_move' }))
  ];
  return allMoves;
}

/* ===== AI PLAYER ===== */
function toggleAI() {
  gameState.aiEnabled = !gameState.aiEnabled;
  aiToggleBtn.textContent = `Play vs AI: ${gameState.aiEnabled ? 'On' : 'Off'}`;
  if (gameState.aiEnabled) {showAlert("AI Enabled. Black will be controlled by the AI.");}
  else {showAlert("AI Disabled. Both players are human-controlled.");}
  aiDifficulty.style.display = gameState.aiEnabled ? 'inline-block' : 'none';
  if (gameState.aiEnabled && gameState.currentPlayer === 'black') {
    setTimeout(makeAIMove, 500);
  }
}

function makeAIMove() {
  if (gameState.isGameOver || gameState.currentPlayer !== 'black') return;

  const me = gameState.players.black;

  // Handle AI initial placement
  if (!me.pos) {
    for (let r = 0; r < 4; r++) {
      for (let c = 0; c < 4; c++) {
        const card = gameState.board[r][c];
        if (card.name === CARD_TYPES.START_KING.name && !isOccupied(r, c)) {
          me.pos = { r, c };
          gameState.board[r][c].isFaceUp = true;
          setMessage(`${cap(gameState.currentPlayer)} places their token.`);
          renderBoard();
          if (gameState.players.white.pos && gameState.players.black.pos) {
            gameState.currentPlayer = 'white';
            setMessage("White's turn. Select your token.");
            autoSelectToken();
          }
          saveState();
          return;
        }
      }
    }
    if (gameState.debug) console.error("AI could not find a START_KING card to place on!");
    return;
  }

  // Handle AI capture placement
  if (gameState.turnAction === 'capture_placement') {
    const { opponentColor } = gameState.capturePlacementData;
    const capSpots = gameState.highlights.capSpots;
    if (capSpots.length > 0) {
      const spotKey = capSpots[Math.floor(Math.random() * capSpots.length)];
      const [r, c] = spotKey.split(',').map(Number);
      gameState.players[opponentColor].pos = { r, c };
      if (!gameState.board[r][c].isFaceUp) {
        gameState.board[r][c].isFaceUp = true;
      }
      gameState.turnAction = null;
      gameState.capturePlacementData = null;
      clearHighlights();
      renderBoard();
      endTurn();
    }
    return;
  }

  gameState.aiThinking = true;
  setMessage("AI is thinking...");

  const allMoves = generateAllMovesForPlayer('black');
  if (allMoves.length === 0) {
    gameState.aiThinking = false;
    return;
  }

  let bestMove = null;
  if (gameState.aiDifficulty === 'easy') {
    bestMove = allMoves[Math.floor(Math.random() * allMoves.length)];
  } else {
    let bestScore = -Infinity;
    for (const move of allMoves) {
      const score = evaluateMove('black', move);
      if (score > bestScore) {
        bestScore = score;
        bestMove = move;
      }
    }
  }

  if (bestMove) {
    handleMove(bestMove.r, bestMove.c, bestMove);
  }

  gameState.aiThinking = false;
}

function evaluateMove(aiColor, move) {
  let score = Math.random() * 0.1;
  const opponentColor = aiColor === 'white' ? 'black' : 'white';
  const toR = move.r;
  const toC = move.c;

  if (move.isCapture) {
    score += 100;
  }
  if (!gameState.board[toR][toC].isFaceUp) {
    score += 10;
  }

  const cardPower = { 
    'Queen': 5, 
    'Rook': 4, 
    'Knight': 3, 
    'Bishop': 3, 
    'King': 2, 
    'Mushroom Ring': 3, 
    'King Start': 1
  };
  const targetCard = gameState.board[toR][toC];
  score += cardPower[targetCard.name] || 0;

  const oppPos = gameState.players[opponentColor].pos;
  if (oppPos) {
    const dist = Math.abs(toR - oppPos.r) + Math.abs(toC - oppPos.c);
    if (dist === 1 && !move.isCapture) {
      score -= 20;
    }
  }

  if (gameState.aiDifficulty === 'hard') {
    const centerDist = Math.abs(toR - 1.5) + Math.abs(toC - 1.5);
    score -= centerDist * 2;
    const oppMoves = generateAllMovesForPlayer(opponentColor);
    if (oppMoves.some(m => m.isCapture && m.r === toR && m.c === toC)) {
      score -= 30;
    }
  }

  return score;
}

// Start the game
init();
</script>
</body>
</html>
