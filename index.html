<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>WAK — 1.0.5.13</title>
<style>
  :root{
    --bg1:#0b1d16; /* deep forest */
    --bg2:#123726; /* mid */
    --bg3:#1d4d35; /* light canopy */
    --panel:#14241d;
    --panel-2:#1e2f27;
    --accent:#8fd3a8;   /* soft moss */
    --accent-2:#cbeac6; /* highlight */
    --warn:#e57373;     /* red for captures/blocked */
    --gold:#f7d774;     /* selection */
    --ink:#e9f5ee;      /* text */
    --muted:#a8c7b6;
  }

  /* CSS-only "forest" background */
  body{
    margin:0;
    color:var(--ink);
    background:
      /* fog layer */
      radial-gradient(1200px 600px at 50% 120%, rgba(255,255,255,0.04), transparent 60%),
      /* canopy gradients */
      linear-gradient(180deg, var(--bg3) 0%, var(--bg2) 45%, var(--bg1) 100%),
      /* trunks: repeated narrow dark stripes */
      repeating-linear-gradient(90deg,
        rgba(0,0,0,0.12) 0px, rgba(0,0,0,0.12) 2px,
        transparent 2px, transparent 18px);
    min-height:100vh;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }

  .wrap{
    max-width: 980px;
    margin: 24px auto;
    padding: 16px;
  }

  h1{
    margin:0 0 6px 0;
    font-weight:700;
    letter-spacing:.5px;
  }
  .sub{ color:var(--muted); margin-bottom:16px; }

  .row{
    display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start;
  }

  .panel{
    background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
    border:1px solid rgba(255,255,255,0.06);
    border-radius:12px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
  }

  /* Player info */
  .players{
    display:flex; gap:12px; width:100%;
  }
  .player{
    flex:1; padding:12px; text-align:center;
  }
  .turn{ outline:2px solid var(--accent); }

  /* Board */
  .board-wrap{
    display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start;
  }
  .board{
    width: min(88vw, 520px);
    aspect-ratio:1/1;
    display:grid;
    grid-template-columns: repeat(4, 1fr);
    gap:6px;
    padding:6px;
  }

  .card{
    position:relative;
    border-radius:10px;
    display:flex; flex-direction:column;
    overflow:hidden;
    transition: transform .15s ease, box-shadow .15s ease, filter .15s ease;
    cursor:pointer;
    user-select:none;
    border:1px solid rgba(255,255,255,0.06);
  }
  .card.face-up{
    background: linear-gradient(180deg, #1e3a2f 0%, #284b3b 100%);
  }
  .card.face-down{
    background:
      linear-gradient(135deg, #2a3e34 0%, #1b3128 100%),
      repeating-linear-gradient(45deg,
        rgba(255,255,255,0.06) 0 6px,
        rgba(255,255,255,0.02) 6px 12px);
    filter:saturate(.9);
  }
  .card.impassable{
    transform: rotate(90deg);
    background: linear-gradient(180deg, #334a41 0%, #2a3e34 100%);
    filter: grayscale(.1) brightness(.95);
  }
  .name{
    font-size: .85rem;
    text-align:center;
    padding:6px 4px 0 4px;
    color:var(--accent-2);
    min-height: 20%;
  }
  .token-area{
    flex:1; display:flex; align-items:center; justify-content:center;
    position:relative;
  }

  /* Tokens & cube */
  .token{
    width:66%; height:66%;
    border-radius:50%;
    display:flex; align-items:center; justify-content:center;
    font-weight:800; font-size:1.4rem;
    border:3px solid rgba(0,0,0,.65);
    box-shadow: 0 6px 16px rgba(0,0,0,.35);
    position:absolute;
    z-index:2;
  }
  .white{ background:#f0f6f3; color:#1f2d28; }
  .black{ background:#22352c; color:#e8f3ee; border-color: rgba(255,255,255,.75); }
  .bloodied{ box-shadow: 0 0 12px var(--warn), inset 0 0 6px var(--warn); border-color: var(--warn); }

  .cube{
    width:50%; height:50%;
    background:#2e5a48; color:#e6fff2; border:2px solid #091a14;
    display:flex; align-items:center; justify-content:center;
    font-weight:800; letter-spacing:.5px;
    position:absolute; z-index:1;
    box-shadow: 0 4px 12px rgba(0,0,0,.35);
  }
  .blocked{ outline:3px solid var(--warn); outline-offset:-3px; }

  /* Highlights */
  .hl-move{ box-shadow: inset 0 0 0 4px rgba(143,211,168,.85); }
  .hl-cap{  box-shadow: inset 0 0 0 4px rgba(229,103,103,.95); }
  .hl-sel{  outline:3px solid var(--gold); outline-offset:-3px; z-index:3; }
  .hl-cube{ box-shadow: inset 0 0 0 4px rgba(247,215,116,.95); } /* block cube highlight */
  /* Hover polish */
  .card:not(.impassable):hover{ transform: scale(1.03); }
  .card.impassable:hover{ transform: rotate(90deg) scale(1.0); cursor:not-allowed; }

  /* Controls & messages */
  .controls{
    display:flex; gap:8px; flex-wrap:wrap; align-items:center;
  }
  .btn{
    background:#244d3b; border:1px solid rgba(255,255,255,0.08);
    color:var(--ink);
    padding:8px 12px; border-radius:10px; cursor:pointer;
    transition: transform .1s ease, filter .1s ease, background .2s;
  }
  .btn:hover{ filter:brightness(1.1); transform:translateY(-1px); }
  .btn:disabled{ opacity:.5; cursor:not-allowed; }
  .choice{ display:none; gap:8px; }
  .choice.show{ display:flex; }

  .message{
    padding:10px 12px; min-height:24px; color:var(--accent-2);
  }

  /* Modal */
  .backdrop{
    position:fixed; inset:0; background: rgba(0,0,0,.6);
    display:flex; align-items:center; justify-content:center;
  }
  .modal{
    background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
    border:1px solid rgba(255,255,255,0.08);
    color:var(--ink);
    padding:20px; border-radius:14px; width:min(92vw, 420px);
    text-align:center;
    box-shadow: 0 16px 40px rgba(0,0,0,.45);
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1>We Are Kings</h1>
    <div class="sub">Best of three • 4×4 • Forest ruleset</div>

    <div class="players row">
      <div id="player-white-info" class="panel player">
        <div style="font-weight:700">Player White</div>
        <div>Captures: <span id="white-captures">0</span>/2</div>
        <div>Matches Won: <span id="white-matches">0</span></div>
      </div>
      <div id="player-black-info" class="panel player">
        <div style="font-weight:700">Player Black</div>
        <div>Captures: <span id="black-captures">0</span>/2</div>
        <div>Matches Won: <span id="black-matches">0</span></div>
      </div>
    </div>

    <div class="board-wrap row" style="margin-top:12px;">
      <div class="panel board" id="game-board"></div>
      <div class="panel" style="flex:1; min-width:260px; padding:12px; display:flex; flex-direction:column; gap:10px;">
        <div class="message" id="message-board"></div>
        <div class="controls">
          <button id="undo-btn" class="btn">Undo</button>
        </div>
        <div id="move-choice" class="choice">
          <button id="king-move-btn" class="btn">King Action</button>
          <button id="card-move-btn" class="btn">Card Action</button>
          <button id="mushroom-move-btn" class="btn">Mushroom Teleport</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div id="modal" class="backdrop" style="display:none;">
    <div class="modal">
      <h2 id="modal-title" style="margin:0 0 8px 0;">Begin Match</h2>
      <p id="modal-text" style="margin:0 0 14px 0;">White goes first.</p>
      <button id="modal-button" class="btn">Start</button>
    </div>
  </div>

<script>
/* ===== Card Types ===== */
const CARD_TYPES = {
  KING:       { name: 'King',          move: 'king' },
  ROOK:       { name: 'Rook',          move: 'rook' },
  BISHOP:     { name: 'Bishop',        move: 'bishop' },
  KNIGHT:     { name: 'Knight',        move: 'knight' },
  QUEEN:      { name: 'Queen',         move: 'queen' },
  MUSHROOM:   { name: 'Mushroom Ring', move: 'mushroom' },
  START_KING: { name: 'King Start',    move: 'king', impassableName: 'Mushroom Ring' },
};

/* ===== DOM ===== */
const gameBoard    = document.getElementById('game-board');
const messageBoard = document.getElementById('message-board');
const undoBtn      = document.getElementById('undo-btn');
const choiceBar    = document.getElementById('move-choice');
const kingBtn      = document.getElementById('king-move-btn');
const cardBtn      = document.getElementById('card-move-btn');
const mushBtn      = document.getElementById('mushroom-move-btn');

const modal        = document.getElementById('modal');
const modalTitle   = document.getElementById('modal-title');
const modalText    = document.getElementById('modal-text');
const modalButton  = document.getElementById('modal-button');

/* ===== Game State ===== */
let gameState = {
  board: [],
  players: {
    white: { token:'W', captures:0, matches:0, isBloodied:false, pos:null },
    black: { token:'B', captures:0, matches:0, isBloodied:false, pos:null },
  },
  currentPlayer: 'white',
  turnCount: 0,
  selectedTokenPos: null,

  actionChosen: false,              // ✅ only one action per turn
  turnAction: null,                 // 'king_block' | 'capture_placement' | null
  capturePlacementData: null,       // { opponentColor, fromR, fromC }
  blockCubePos: null,               // {r,c} location of cube (impassable)
  lastCaptureOrigin: null,          // {r,c} square the capturing piece left
  justCaptured: null,               // 'white' | 'black' (the side just captured last turn)
  isGameOver: false,

  highlights: {
    map: new Map(),                 // "r,c" -> {type:'king_move'|'action_move'|'mushroom_move', isCapture:boolean}
    capSpots: new Set(),            // "r,c" valid placement after capture
    selection: null,                // {r,c}
  }
};

/* ===== History (Undo) ===== */
let history = [];
function saveState(){
  const copy = JSON.parse(JSON.stringify(gameState));
  copy.highlights.capSpots = Array.from(gameState.highlights.capSpots);
  copy.highlights.map = Array.from(gameState.highlights.map.entries());
  history.push(JSON.stringify(copy));
}
function undoMove(){
  if (!history.length) return;
  const saved = JSON.parse(history.pop());
  saved.highlights.map = new Map(saved.highlights.map);
  saved.highlights.capSpots = new Set(saved.highlights.capSpots);
  gameState = saved;
  renderBoard();
  setMessage("Undone.");
}

/* ===== Helpers ===== */
const keyRC = (r,c)=>`${r},${c}`;
const cap = s => s[0].toUpperCase()+s.slice(1);
const setMessage = txt => messageBoard.textContent = txt;

function isValidPosition(r,c){ return r>=0 && r<4 && c>=0 && c<4; }
function isOccupiedByPlayer(r,c,color){
  const p = gameState.players[color].pos;
  return p && p.r===r && p.c===c;
}
function isOccupied(r,c){ return isOccupiedByPlayer(r,c,'white') || isOccupiedByPlayer(r,c,'black'); }
function isImpassable(r,c){
  const card = gameState.board[r][c];
  if (card.isImpassable) return true;
  if (gameState.blockCubePos && gameState.blockCubePos.r===r && gameState.blockCubePos.c===c) return true;
  return false;
}
function isValidMove(r,c){ return isValidPosition(r,c) && !isImpassable(r,c); }

function countFaceDown(){
  let n=0;
  for (let r=0;r<4;r++) for (let c=0;c<4;c++) if (!gameState.board[r][c].isFaceUp) n++;
  return n;
}
function clearHighlights(){
  gameState.highlights.map.clear();
  gameState.highlights.capSpots.clear();
  gameState.highlights.selection = null;
}
function updatePlayerInfo(){
  document.getElementById('white-captures').textContent = gameState.players.white.captures;
  document.getElementById('black-captures').textContent = gameState.players.black.captures;
  document.getElementById('white-matches').textContent  = gameState.players.white.matches;
  document.getElementById('black-matches').textContent  = gameState.players.black.matches;
}
function updateTurnIndicator(){
  const wi = document.getElementById('player-white-info');
  const bi = document.getElementById('player-black-info');
  wi.classList.remove('turn'); bi.classList.remove('turn');
  (gameState.currentPlayer==='white' ? wi : bi).classList.add('turn');
}

/* ===== Setup & Match Flow ===== */
function init(){
  modal.style.display='flex';
  modalTitle.textContent = "Begin Match";
  modalText.textContent  = "White goes first.";
  modalButton.textContent = "Start";
  modalButton.onclick = () => { modal.style.display='none'; startNewMatch(); };
}

function startNewMatch(){
  gameState.isGameOver = false;
  for (const side of ['white','black']){
    const p = gameState.players[side];
    p.captures=0; p.isBloodied=false; p.pos=null;
  }
  gameState.blockCubePos = null;
  gameState.selectedTokenPos = null;
  gameState.actionChosen = false;
  gameState.turnAction = null;
  gameState.capturePlacementData = null;
  clearHighlights();
  setupBoard();
  renderBoard();
  gameState.currentPlayer = 'white';
  updateTurnIndicator();
  setMessage(`${cap(gameState.currentPlayer)}, place your token on a 'King Start' card.`);
  history = []; // reset undo history at new match start
}

function setupBoard(){
  const deck = [
    ...Array(4).fill(CARD_TYPES.KING),
    ...Array(4).fill(CARD_TYPES.ROOK),
    ...Array(2).fill(CARD_TYPES.BISHOP),
    ...Array(2).fill(CARD_TYPES.KNIGHT),
    ...Array(2).fill(CARD_TYPES.QUEEN),
  ];
  // shuffle
  for (let i=deck.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }

  const grid = Array(16).fill(null);
  grid[0]  = CARD_TYPES.START_KING;
  grid[15] = CARD_TYPES.START_KING;

  let di=0;
  for (let i=0;i<16;i++) if (!grid[i]) grid[i] = deck[di++];

  gameState.board = [];
  for (let r=0;r<4;r++){
    gameState.board[r]=[];
    for (let c=0;c<4;c++){
      const card = grid[r*4+c];
      gameState.board[r][c] = {
        ...card,
        isFaceUp: card.name === CARD_TYPES.START_KING.name ? true : false,
        isImpassable: false,
        row:r, col:c,
      };
    }
  }
  // center 4 face-up
  gameState.board[1][1].isFaceUp = true;
  gameState.board[1][2].isFaceUp = true;
  gameState.board[2][1].isFaceUp = true;
  gameState.board[2][2].isFaceUp = true;
}

/* ===== Rendering ===== */
function renderBoard(){
  gameBoard.innerHTML='';
  for (let r=0;r<4;r++){
    for (let c=0;c<4;c++){
      const card = gameState.board[r][c];
      const cell = document.createElement('div');
      cell.className = 'card';
      cell.dataset.row = r; cell.dataset.col = c;

      cell.classList.add(card.isFaceUp ? 'face-up' : 'face-down');
      if (card.isImpassable && !card.impassableName) cell.classList.add('impassable');

      // Name row
      const nameDiv = document.createElement('div');
      nameDiv.className = 'name';
      let displayName = card.isFaceUp ? card.name : '';
      if (card.isImpassable && card.impassableName) displayName = card.impassableName;
      nameDiv.textContent = displayName;
      cell.appendChild(nameDiv);

      // Token/cube layer
      const area = document.createElement('div');
      area.className = 'token-area';

      // Cube
      if (gameState.blockCubePos && gameState.blockCubePos.r===r && gameState.blockCubePos.c===c){
        cell.classList.add('blocked');
        const cube = document.createElement('div');
        cube.className = 'cube';
        cube.textContent = 'B';
        area.appendChild(cube);
      }

      // Tokens
      if (isOccupiedByPlayer(r,c,'white')) area.appendChild(makeToken('white'));
      if (isOccupiedByPlayer(r,c,'black')) area.appendChild(makeToken('black'));

      cell.appendChild(area);

      // Highlights
      const key = keyRC(r,c);
      if (gameState.highlights.selection && gameState.highlights.selection.r===r && gameState.highlights.selection.c===c){
        cell.classList.add('hl-sel');
      } else if (gameState.turnAction === 'capture_placement' && gameState.highlights.capSpots.has(key)){
        cell.classList.add('hl-move');
      } else if (gameState.turnAction === 'king_block'){
        if (!isOccupied(r,c) && !isImpassable(r,c)) cell.classList.add('hl-cube');
      } else if (gameState.highlights.map.has(key)){
        const info = gameState.highlights.map.get(key);
        cell.classList.add(info.isCapture ? 'hl-cap' : 'hl-move');
      }

      cell.addEventListener('click', ()=> onCellClick(r,c));
      gameBoard.appendChild(cell);
    }
  }
  updatePlayerInfo();
  updateTurnIndicator();
}

function makeToken(color){
  const d = document.createElement('div');
  d.className = `token ${color}`;
  d.textContent = gameState.players[color].token;
  if (gameState.players[color].isBloodied) d.classList.add('bloodied');
  return d;
}

/* ===== Click Flow ===== */
function onCellClick(r,c){
  if (gameState.isGameOver) return;

  // Initial placements
  if (!gameState.players.white.pos || !gameState.players.black.pos){
    return handleInitialPlacement(r,c);
  }

  // Capture relocation phase
  if (gameState.turnAction === 'capture_placement'){
    const key = keyRC(r,c);
    if (!gameState.highlights.capSpots.has(key)){
      setMessage("Choose a highlighted adjacent cell.");
      return;
    }
    const { opponentColor, fromR, fromC } = gameState.capturePlacementData;
    gameState.players[opponentColor].pos = { r,c };

    // Flip destination if facedown; if it was the last facedown, the RELOCATED player wins. ✅ bug fix
    if (!gameState.board[r][c].isFaceUp){
      gameState.board[r][c].isFaceUp = true;
      if (countFaceDown() === 0){
        endGame(opponentColor, "flipped the last face-down card on relocation!");
        return;
      }
    }

    // Origin becomes impassable (start becomes mushroom ring impassable)
    const origin = gameState.board[fromR][fromC];
    if (origin.name === CARD_TYPES.START_KING.name){
      origin.name = CARD_TYPES.MUSHROOM.name;
      origin.move = 'mushroom';
      origin.isFaceUp = true;
      origin.isImpassable = true;
    } else {
      origin.isImpassable = true;
    }

    gameState.capturePlacementData = null;
    gameState.turnAction = null;
    clearHighlights();
    endTurn();
    return;
  }

  // King action -> cube placement
  if (gameState.turnAction === 'king_block'){
    if (!isOccupied(r,c) && !isImpassable(r,c)){
      gameState.blockCubePos = { r,c }; // does NOT flip facedown cards
      gameState.turnAction = null;
      endTurn();
    } else {
      setMessage("Invalid block placement.");
    }
    return;
  }

  // normal selection / move choice
  const me = gameState.players[gameState.currentPlayer];
  if (me.pos && me.pos.r===r && me.pos.c===c){
    // Toggle selection
    if (gameState.selectedTokenPos && gameState.selectedTokenPos.r===r && gameState.selectedTokenPos.c===c){
      gameState.selectedTokenPos = null;
      clearHighlights();
      choiceBar.classList.remove('show');
      renderBoard();
      return;
    }

    gameState.selectedTokenPos = { r,c };
    clearHighlights();
    gameState.highlights.selection = { r,c };
    showChoices(r,c);
    renderBoard();
    return;
  }

  // Clicking a highlighted move
  const key = keyRC(r,c);
  if (gameState.highlights.map.has(key)){
    const info = gameState.highlights.map.get(key);
    handleMove(r,c,info);
    return;
  }

  // Otherwise clear selection
  gameState.selectedTokenPos = null;
  clearHighlights();
  choiceBar.classList.remove('show');
  renderBoard();
}

function handleInitialPlacement(r,c){
  const cell = gameState.board[r][c];
  if (cell.name !== CARD_TYPES.START_KING.name){
    setMessage("Place on a 'King Start' card.");
    return;
  }
  const other = gameState.currentPlayer === 'white' ? 'black' : 'white';
  if (gameState.players[other].pos && gameState.players[other].pos.r===r && gameState.players[other].pos.c===c){
    setMessage("That start card is occupied.");
    return;
  }
  gameState.players[gameState.currentPlayer].pos = { r,c };

  if (!gameState.players.white.pos || !gameState.players.black.pos){
    gameState.currentPlayer = other;
    updateTurnIndicator();
    setMessage(`${cap(gameState.currentPlayer)}, place your token on a 'King Start' card.`);
  } else {
    gameState.currentPlayer = 'white';
    updateTurnIndicator();
    setMessage("White's turn. Select your token to choose an action.");
  }
  renderBoard();
}

/* ===== Action Choice UI ===== */
function showChoices(r,c){
  choiceBar.classList.add('show');

  kingBtn.onclick = () => {
    if (gameState.actionChosen) return;
    highlightKingMoves(r,c);
  };
  cardBtn.onclick = () => {
    if (gameState.actionChosen) return;
    highlightCardMoves(r,c);
  };
  mushBtn.onclick = () => {
    if (gameState.actionChosen) return;
    highlightMushroomMoves(r,c);
  };
}

/* ===== Move Generation ===== */
function highlightKingMoves(r,c){
  clearHighlights();
  gameState.highlights.selection = { r,c };
  const moves = [];
  for (let dr=-1; dr<=1; dr++){
    for (let dc=-1; dc<=1; dc++){
      if (dr===0 && dc===0) continue;
      const nr=r+dr, nc=c+dc;
      if (isValidMove(nr,nc) && !isOccupied(nr,nc)){
        moves.push({ r:nr, c:nc, type:'king_move', isCapture:false });
      }
    }
  }
  for (const m of moves) gameState.highlights.map.set(keyRC(m.r,m.c), m);
  setMessage("King Action: move 1, then place block cube.");
  renderBoard();
}

function highlightCardMoves(r,c){
  clearHighlights();
  gameState.highlights.selection = { r,c };
  const me = gameState.currentPlayer;
  const pieceMoves = getPieceMoves(r,c, gameState.board[r][c].move, me)
    .map(m => ({...m, type:'action_move'}));
  for (const m of pieceMoves) gameState.highlights.map.set(keyRC(m.r,m.c), m);
  setMessage("Card Action: move by the card's pattern (capture allowed).");
  renderBoard();
}

function highlightMushroomMoves(r,c){
  clearHighlights();
  gameState.highlights.selection = { r,c };
  const moves = [];
  for (let row=0; row<4; row++){
    for (let col=0; col<4; col++){
      const t = gameState.board[row][col];
      if (row===r && col===c) continue;
      if (t.move==='mushroom' && t.isFaceUp && !t.isImpassable && !isOccupied(row,col)){
        moves.push({ r:row, c:col, type:'mushroom_move', isCapture:false });
      }
    }
  }
  for (const m of moves) gameState.highlights.map.set(keyRC(m.r,m.c), m);
  setMessage("Mushroom Teleport: jump to any face-up mushroom (then it turns).");
  renderBoard();
}

function getPieceMoves(r,c,piece,meColor){
  const opp = meColor==='white' ? 'black' : 'white';
  const moves=[];
  const dirs={
    rook:  [[-1,0],[1,0],[0,-1],[0,1]],
    bishop:[[-1,-1],[-1,1],[1,-1],[1,1]],
    queen: [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]],
    king:  [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]],
    knight:[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]],
  };
  const sliding = ['rook','bishop','queen'].includes(piece);
  const vecs = dirs[piece] || [];

  const isLastOrigin = gameState.lastCaptureOrigin &&
    gameState.lastCaptureOrigin.r === r && gameState.lastCaptureOrigin.c === c;
  const wasJustCaptured = gameState.justCaptured === meColor;

  for (const [dr,dc] of vecs){
    let nr=r+dr, nc=c+dc;
    if (sliding){
      while (isValidPosition(nr,nc)){
        if (isImpassable(nr,nc)) break;
        if (isOccupiedByPlayer(nr,nc,meColor)) break;
        const isCap = isOccupiedByPlayer(nr,nc,opp);
        // no immediate recapture
        if (!(isCap && (wasJustCaptured || isLastOrigin))){
          moves.push({ r:nr, c:nc, isCapture:isCap });
        }
        if (isCap) break;
        nr+=dr; nc+=dc;
      }
    } else { // king or knight step
      if (isValidPosition(nr,nc)){
        const canJump = (piece==='knight');
        if ((canJump || !isImpassable(nr,nc)) && !isOccupiedByPlayer(nr,nc,meColor)){
          const isCap = isOccupiedByPlayer(nr,nc,opp);
          if (!(isCap && (wasJustCaptured || isLastOrigin))){
            moves.push({ r:nr, c:nc, isCapture:isCap });
          }
        }
      }
    }
  }
  return moves;
}

/* ===== Execute Move ===== */
function handleMove(toR, toC, info){
  if (gameState.actionChosen) return; // ✅ safety
  const meColor = gameState.currentPlayer;
  const oppColor= meColor==='white' ? 'black':'white';
  const fromR = gameState.selectedTokenPos.r;
  const fromC = gameState.selectedTokenPos.c;

  // no immediate recapture guard (extra)
  const isLastOrigin = gameState.lastCaptureOrigin &&
    gameState.lastCaptureOrigin.r===fromR && gameState.lastCaptureOrigin.c===fromC;
  const wasJustCaptured = gameState.justCaptured === meColor;
  if (info.isCapture && (wasJustCaptured || isLastOrigin)){
    setMessage("Cannot immediately recapture.");
    clearHighlights(); renderBoard(); return;
  }

  saveState();

  const fromCard = gameState.board[fromR][fromC];
  const toCard   = gameState.board[toR][toC];

  // Move
  gameState.players[meColor].pos = { r:toR, c:toC };
  clearHighlights();

  // Flip destination if facedown
  if (!toCard.isFaceUp){
    toCard.isFaceUp = true;
    // If last face-down flipped by the mover, the mover wins.
    if (countFaceDown() === 0){
      endGame(meColor, "flipped the last face-down card!");
      return;
    }
  }

  // Capture handling
  if (info.isCapture){
    handleCapture(oppColor, toR, toC, fromR, fromC);
    gameState.actionChosen = true;
    saveState();
    return;
  }

  // Post-action card turning / flow
  if (info.type === 'king_move'){
    // Start card becomes mushroom ring (not impassable yet for king move), then place cube
    if (fromCard.name === CARD_TYPES.START_KING.name){
      fromCard.name = CARD_TYPES.MUSHROOM.name;
      fromCard.move = 'mushroom';
      fromCard.isFaceUp = true;
      fromCard.isImpassable = false;
    }
    gameState.actionChosen = true;
    gameState.turnAction = 'king_block';
    setMessage(`${cap(meColor)}: place the block cube.`);
    renderBoard();
    return;
  }

  if (info.type === 'action_move'){
    // After using a card action, the origin turns impassable (start becomes mushroom impassable)
    if (fromCard.name === CARD_TYPES.START_KING.name){
      fromCard.name = CARD_TYPES.MUSHROOM.name;
      fromCard.move = 'mushroom';
      fromCard.isFaceUp = true;
      fromCard.isImpassable = true;
    } else {
      fromCard.isImpassable = true;
    }
    gameState.actionChosen = true;
    endTurn();
    return;
  }

  if (info.type === 'mushroom_move'){
    // Teleported mushroom becomes impassable (the destination ring)
    toCard.isImpassable = true;
    gameState.actionChosen = true;
    endTurn();
    return;
  }
}

function handleCapture(opponentColor, captureR, captureC, fromR, fromC){
  // wound opponent
  gameState.players[opponentColor].isBloodied = true;
  gameState.players[gameState.currentPlayer].captures++;

  gameState.lastCaptureOrigin = { r: fromR, c: fromC };
  gameState.justCaptured = opponentColor;

  // Build adjacent placement spots (not the origin square)
  const valid=[];
  for (let dr=-1; dr<=1; dr++){
    for (let dc=-1; dc<=1; dc++){
      if (dr===0 && dc===0) continue;
      const nr=captureR+dr, nc=captureC+dc;
      if (!isValidPosition(nr,nc)) continue;
      if (isOccupied(nr,nc)) continue;
      if (isImpassable(nr,nc)) continue;
      if (nr===fromR && nc===fromC) continue;
      valid.push({r:nr,c:nc});
    }
  }

  if (!valid.length){
    endGame(gameState.currentPlayer, "opponent had no adjacent placement.");
    return;
  }

  gameState.turnAction = 'capture_placement';
  gameState.capturePlacementData = { opponentColor, fromR, fromC };
  gameState.highlights.capSpots = new Set(valid.map(p=>keyRC(p.r,p.c)));
  setMessage("Capture! Place your opponent on a highlighted adjacent card.");

  renderBoard();

  // Immediate 2 captures = win
  if (gameState.players[gameState.currentPlayer].captures >= 2){
    endGame(gameState.currentPlayer, "captured twice!");
  }
}

/* ===== Turn & Win Flow ===== */
function endTurn(){
  if (gameState.isGameOver) return;

  gameState.selectedTokenPos = null;
  clearHighlights();
  choiceBar.classList.remove('show');

  // Reset action flag
  gameState.actionChosen = false;

  // Reset justCaptured marker at the end of THIS side's turn
  if (gameState.justCaptured === gameState.currentPlayer){
    gameState.justCaptured = null;
  }

  gameState.turnCount++;
  gameState.currentPlayer = gameState.currentPlayer==='white' ? 'black' : 'white';

  updateTurnIndicator();
  renderBoard();

  // Stalemate: no legal moves for side to play
  if (!hasAnyLegalMoves(gameState.currentPlayer)){
    const winner = gameState.currentPlayer==='white' ? 'black':'white';
    endGame(winner, `${cap(gameState.currentPlayer)} has no legal moves.`);
    return;
  }
  setMessage(`${cap(gameState.currentPlayer)}'s turn.`);
}

function hasAnyLegalMoves(color){
  const p = gameState.players[color];
  if (!p.pos) return false;
  // Combine all potential actions quickly to test existence
  const r=p.pos.r, c=p.pos.c;

  // any king step?
  for (let dr=-1; dr<=1; dr++) for (let dc=-1; dc<=1; dc++){
    if (dr||dc){
      const nr=r+dr, nc=c+dc;
      if (isValidMove(nr,nc) && !isOccupied(nr,nc)) return true;
    }
  }

  // any card move?
  const pieceMoves = getPieceMoves(r,c, gameState.board[r][c].move, color);
  if (pieceMoves.length) return true;

  // any mushroom move?
  for (let row=0; row<4; row++) for (let col=0; col<4; col++){
    const t = gameState.board[row][col];
    if (t.move==='mushroom' && t.isFaceUp && !t.isImpassable && !isOccupied(row,col) && !(row===r && col===c)) return true;
  }

  return false;
}

function endGame(winner, reason){
  gameState.isGameOver = true;
  gameState.players[winner].matches++;
  updatePlayerInfo();

  const wName = cap(winner);
  modalTitle.textContent = `${wName} wins the match!`;
  modalText.textContent  = `Reason: ${reason}`;
  modalButton.textContent = (gameState.players[winner].matches>=2) ? "Play Again" : "Next Match";
  modal.style.display='flex';

  modalButton.onclick = () => {
    if (gameState.players[winner].matches>=2){
      // new game
      gameState.players.white.matches = 0;
      gameState.players.black.matches = 0;
    }
    modal.style.display='none';
    startNewMatch();
  };
}

/* ===== Events ===== */
undoBtn.addEventListener('click', undoMove);

/* ===== Start ===== */
init();
</script>
</body>
</html>
